import json
from turfpy import measurement
from turfpy.measurement import destination
from geojson import Point, Feature
import decimal_coodinates
import exif
import math

from geographiclib.constants import Constants
from geographiclib.geodesic import Geodesic

# image_name = '48879831437_34b36f2c7a_o.jpg'
image_name = '39081697872_536d8bd641_o.jpg'

# Sensors Length/Width
# Old Picture
# SENw = 13.2
# SENl = 8.8

# SENw = 0.00616
# SENl = 0.00462

SENw = 9.6
SENl = 5.4

# Screen size in pexels
# screen_width = 5464
# screen_length = 3640
screen_width = 3992
screen_length = 2992

def getEndpoint(lat1, lon1, bearing, d):
    geod = Geodesic(Constants.WGS84_a, Constants.WGS84_f)
    d = geod.Direct(lat1, lon1, bearing, d)
    return d['lat2'], d['lon2']

# This function returns alpht or beta, which it is the lens degree
def get_alpha_beta(sensor):
    focal_lenght = exif.get_focal_length(image_name) 
    # print("Focal Length", focal_lenght)
    alpha = 2*(math.atan(sensor/(2*focal_lenght)))
    degrees = math.degrees(alpha)

    return degrees

#returns current location
def get_current_location():
    return Feature(geometry=Point(decimal_coodinates.get_coordinatess(image_name)))


# This function calculates the camera width angle (alpha) in meters
def get_real_world_width():
    # Start by getting alpth using get_alpha_beta function.
    alpha = get_alpha_beta(SENw)
    height = exif.get_height(image_name)   
    # print("Height", height)

    # changing tan to radians for calculation.
    tan = (math.tan(math.radians(alpha)/2))
    Wr = (2*height)*tan
    # print ("Real Width: ", Wr)
    return Wr

# This function calculates the camera length angle (beta) in meters
def get_real_world_length():
    # Start by getting beta using get_alpha_beta function.
    beta = get_alpha_beta(SENl)
    # print("beta: ", beta)
    height = exif.get_height(image_name)   
    
    # changing tan to radians for calculation.
    tan = (math.tan(math.radians(beta)/2))
    Lr = (2*height)*tan

    # print ("Real Length: ", Lr)
    return Lr
    
# This functions calculates pixels to meter.
def realSize_to_screenSize(Wr, Lr, Ws, Ls):
    converted_width = (Wr/Ws)
    converted_length = (Lr/Ls)

    return converted_width, converted_length

#Calculates the real distance the drone need to move.
def drone_movement(dest_x, dest_y, current_location):
    Wr = get_real_world_width()
    Lr = get_real_world_length()
    converted = realSize_to_screenSize(Wr, Lr, screen_width, screen_length)

    # calculates the center of the screen.  
    center_x = screen_width/2
    center_y = screen_length/2

    new_location = current_location
    #Converting pixels distance to meters. Positive X means North (Old picture)
    move_x = (dest_x - center_x)*converted[0]
    if(move_x < 0):
        # new_location = calculate_dist(move_x, new_location, 180)
        new_location = getEndpoint(new_location[0], new_location[1], 270, move_x)
    else:
        # new_location = calculate_dist(move_x, new_location, 0)
        new_location = getEndpoint(new_location[0], new_location[1], 90, move_x)
    
    #Converting pixels distance to meters.
    move_y = (dest_y - center_y)*converted[1]
    # print("move y", move_y)
    if(move_y < 0):
        # new_location = calculate_dist(move_y, new_location, 270)
        new_location = getEndpoint(new_location[0], new_location[1], 0, move_y)
    else:
        # new_location = calculate_dist(move_y, new_location, 90)
        new_location = getEndpoint(new_location[0], new_location[1], 180, move_y)

    return new_location

#This function will return the next coordinate by giving it current_location, distance in meters, heigt and direction.
def calculate_dist(distance, curr_location, bearing):
    current_location = Feature(geometry=Point([float(curr_location[0]), float(curr_location[1])]))
    print("Calculate distance", current_location)
    distance = distance
    bearing = bearing
    height = exif.get_height(image_name)
    options = {"units": "m"}
    new_coord = json.dumps(destination(current_location,distance,bearing,options)['geometry']['coordinates'][0], indent=2, sort_keys=True) ,  json.dumps(destination(current_location,distance,bearing,options)['geometry']['coordinates'][1], indent=2, sort_keys=True)

    print("Calculated",new_coord)
    return json.dumps(destination(current_location,distance,bearing,options)['geometry']['coordinates'][0], indent=2, sort_keys=True) ,  json.dumps(destination(current_location,distance,bearing,options)['geometry']['coordinates'][1], indent=2, sort_keys=True)

